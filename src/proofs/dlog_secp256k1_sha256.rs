// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use crate::methods::{DLOG_SECP256K1_SHA256_ELF, DLOG_SECP256K1_SHA256_ID};

use super::dlog_secp256k1_generic::Secp256k1DlogProof;
use crate::program::Program;

/// This program takes in the following secret inputs:
///
/// - `secret_key` (32 bytes)
/// - `secret_nonce` (32 bytes)
/// - `challenge` (32 bytes)
///
/// ...and produces the following public outputs:
///
/// - `challenge` (32 bytes)
/// - `sig_scalar = (secret_key * challenge + secret_nonce) % n` (32 bytes)
/// - `hash = sha256(secret_key)` (32 bytes)
///
/// This program is used to instantiate [`Secp256k1DlogSha256Proof`].
pub struct Secp256k1DlogSha256Program;

impl Program for Secp256k1DlogSha256Program {
    fn id() -> [u32; 8] {
        DLOG_SECP256K1_SHA256_ID
    }
    fn elf() -> &'static [u8] {
        DLOG_SECP256K1_SHA256_ELF
    }
    fn aux_input_len() -> usize {
        0
    }
    fn appendix_len() -> usize {
        32 // sha256 hash of secret key
    }
}

/// A proof that the discrete log (private key) of a given secp256k1 point (public key)
/// is also the preimage of a given SHA256 hash.
///
/// More specifically, this proof asserts that the following relation holds for
/// a 32-byte secp256k1 secret key `k`:
///
/// ```not_rust
/// pubkey = k*G
/// hash   = SHA256(k)
/// ```
///
/// Internally, the zk-STARK proof program doesn't assert `pubkey = k*G`; instead it
/// asserts that the secret key `k` was used to produce a Schnorr signature which
/// verifies under `pubkey`. This improves the speed of proof generation by more
/// than an order of magnitude by avoiding the elliptic curve point math, while still
/// enforcing the same assertion.
pub type Secp256k1DlogSha256Proof = Secp256k1DlogProof<Secp256k1DlogSha256Program>;

impl Secp256k1DlogSha256Proof {
    pub fn new(secret_key: secp::Scalar) -> Result<Self, anyhow::Error> {
        Self::prove_custom(secret_key, b"")
    }

    pub fn hash(&self) -> [u8; 32] {
        <[u8; 32]>::try_from(self.appendix()).expect("length guaranteed by Program::appendix_len")
    }
}
