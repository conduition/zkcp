// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use crate::methods::{DLOG_SECP256K1_SUDOKU_ELF, DLOG_SECP256K1_SUDOKU_ID};

use anyhow::bail;
use chacha20::{
    cipher::{KeyIvInit, StreamCipher},
    ChaCha20,
};
use risc0_zkvm::sha::rust_crypto::{Digest as _, Sha256};
use risc0_zkvm::sha::Digest;
use secp::Scalar;

use super::dlog_secp256k1_generic::Secp256k1DlogProof;
use crate::program::Program;
use common::sudoku::{self, CompactSudokuBoard, SudokuBoard};

/// This program takes in the following secret inputs:
///
/// - `secret_key` (32 bytes)
/// - `secret_nonce` (32 bytes)
/// - `challenge` (32 bytes)
/// - `chacha_nonce` (12 bytes)
/// - `mask` (81 bytes)
/// - `sudoku_solution` (81 bytes)
///
/// It asserts that `sudoku_solution` is a valid sudoku board, and then
/// produces the following public outputs:
///
/// - `challenge` (32 bytes)
/// - `sig_scalar = (secret_key * challenge + secret_nonce) % n` (32 bytes)
/// - `chacha_nonce` (12 bytes)
/// - `sudoku_puzzle = mask_sudoku_solution(sudoku_solution, mask)` (81 bytes)
/// - `compact_encrypted_solution = chacha_cipher(secret_key).encrypt(compress_board(sudoku_solution))` (36 bytes)
///
/// This program is used to instantiate [`Secp256k1DlogSudokuProof`].
pub struct Secp256k1DlogSudokuProgram;

impl Program for Secp256k1DlogSudokuProgram {
    fn id() -> [u32; 8] {
        DLOG_SECP256K1_SUDOKU_ID
    }
    fn elf() -> &'static [u8] {
        DLOG_SECP256K1_SUDOKU_ELF
    }

    // aux input:
    // - chacha nonce: 12 bytes
    // - sudoku puzzle mask: 81 bytes
    // - sudoku solution: 81 bytes
    fn aux_input_len() -> usize {
        12 + 81 + 81
    }

    /// Journal:
    /// - schnorr challenge: 32 bytes
    /// - schnorr sig: 32 bytes
    /// - chacha nonce: 12 bytes
    /// - sudoku puzzle: 81 bytes
    /// - encrypted compact sudoku solution: 36 bytes
    fn appendix_len() -> usize {
        12 + 81 + 36
    }
}

/// A proof that the secret key of a secp256k1 public key is also the decryption key to a valid
/// sudoku solution.
pub type Secp256k1DlogSudokuProof = Secp256k1DlogProof<Secp256k1DlogSudokuProgram>;

impl Secp256k1DlogSudokuProof {
    pub fn new(
        secret_key: Scalar,
        solution: &SudokuBoard,
        puzzle_mask: &SudokuBoard,
    ) -> Result<Self, anyhow::Error> {
        let chacha_nonce_hash = Sha256::new()
            .chain_update(Digest::from(DLOG_SECP256K1_SUDOKU_ID))
            .chain_update(secret_key.serialize())
            .chain_update(solution)
            .chain_update(puzzle_mask)
            .chain_update(b"chacha_nonce")
            .finalize();

        let mut aux_input = [0u8; 12 + 81 + 81];
        aux_input[..12].copy_from_slice(&chacha_nonce_hash[..12]);
        aux_input[12..][..81].copy_from_slice(puzzle_mask);
        aux_input[12..][81..].copy_from_slice(solution);

        Self::prove_custom(secret_key, &aux_input)
    }

    pub fn puzzle(&self) -> SudokuBoard {
        SudokuBoard::try_from(&self.journal()[64..][12..][..81])
            .expect("journal length already checked in constructor")
    }

    pub fn decrypt_solution(&self, secret_key: Scalar) -> Result<SudokuBoard, anyhow::Error> {
        if secret_key.base_point_mul() != self.public_key {
            bail!("secret key does not match public key used in discrete log proof");
        }

        let chacha_key: [u8; 32] = secret_key.serialize();
        let chacha_nonce = <[u8; 12]>::try_from(&self.journal()[64..][..12])?;

        let mut compact_solution = CompactSudokuBoard::try_from(&self.journal()[64..][12..][81..])?;
        let mut cipher = ChaCha20::new(&chacha_key.into(), &chacha_nonce.into());
        cipher.apply_keystream(&mut compact_solution);

        let solution = sudoku::decompress_board(&compact_solution)?;

        if !sudoku::is_valid_sudoku_solution(&solution) {
            bail!("decrypted solution is not valid; this should never happen");
        } else if !sudoku::solves_sudoku_puzzle(&solution, &self.puzzle()) {
            bail!("decrypted solution is for the wrong puzzle; this should never happen");
        }
        Ok(solution)
    }
}
